<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mini Editor Compiler</title>
  <style>
    body {
      margin: 0;
      font-family: monospace;
      background: #0f172a;
      color: #e5e7eb;
      display: flex;
      height: 100vh;
    }

    .editor-container {
      width: 50%;
      padding: 16px;
      box-sizing: border-box;
      border-right: 2px solid #1e293b;
    }

    .output-container {
      width: 50%;
      padding: 16px;
      box-sizing: border-box;
      background: #020617;
    }

    textarea {
      width: 100%;
      height: 75vh;
      background: #020617;
      color: #e5e7eb;
      border: 1px solid #334155;
      padding: 12px;
      font-size: 14px;
      resize: none;
      outline: none;
    }

    button {
      margin-top: 10px;
      padding: 10px 16px;
      background: #38bdf8;
      border: none;
      color: #020617;
      font-weight: bold;
      cursor: pointer;
      border-radius: 6px;
    }

    button:hover {
      background: #0ea5e9;
    }

    .output-box {
      background: #020617;
      border: 1px solid #334155;
      padding: 12px;
      height: 75vh;
      overflow-y: auto;
      white-space: pre-wrap;
    }

    h2 {
      margin-top: 0;
      color: #38bdf8;
    }
  </style>
</head>
<body>
  <div class="editor-container">
    <h2>Code Editor</h2>
    <textarea id="code">
// Mini language example
let x = 5;
let y = 10;
print(x + y);

if (x < y) {
  print("x is smaller");
}

function square(n) {
  return n * n;
}

print(square(4));
    </textarea>
    <br />
    <button onclick="runCode()">â–¶ Run</button>
  </div>

  <div class="output-container">
    <h2>Output</h2>
    <div id="output" class="output-box"></div>
  </div>

  <script>
    function runCode() {
      const code = document.getElementById("code").value;
      const outputDiv = document.getElementById("output");
      outputDiv.textContent = "";

      try {
        const tokens = tokenize(code);
        const ast = parse(tokens);
        const result = interpret(ast);
      } catch (err) {
        outputDiv.textContent += "Error: " + err.message + "\n";
      }
    }

    // ---------------- TOKENIZER ----------------
    function tokenize(input) {
      const tokens = [];
      const regex = /\s*(=>|function|return|let|if|else|print|[A-Za-z_][A-Za-z0-9_]*|\d+|".*?"|==|!=|<=|>=|[+\-*/(){};=<>])\s*/g;
      let match;
      while ((match = regex.exec(input)) !== null) {
        tokens.push(match[1]);
      }
      return tokens;
    }

    // ---------------- PARSER ----------------
    function parse(tokens) {
      let position = 0;

      function peek() {
        return tokens[position];
      }

      function consume() {
        return tokens[position++];
      }

      function parseProgram() {
        const statements = [];
        while (position < tokens.length) {
          statements.push(parseStatement());
        }
        return { type: "Program", body: statements };
      }

      function parseStatement() {
        const token = peek();

        if (token === "let") return parseVariableDeclaration();
        if (token === "print") return parsePrintStatement();
        if (token === "if") return parseIfStatement();
        if (token === "function") return parseFunctionDeclaration();
        if (token === "return") return parseReturnStatement();

        return parseExpressionStatement();
      }

      function parseVariableDeclaration() {
        consume(); // let
        const name = consume();
        consume(); // =
        const value = parseExpression();
        consume(); // ;
        return { type: "VariableDeclaration", name, value };
      }

      function parsePrintStatement() {
        consume(); // print
        consume(); // (
        const argument = parseExpression();
        consume(); // )
        consume(); // ;
        return { type: "PrintStatement", argument };
      }

      function parseIfStatement() {
        consume(); // if
        consume(); // (
        const test = parseExpression();
        consume(); // )
        consume(); // {
        const consequent = [];
        while (peek() !== "}") {
          consequent.push(parseStatement());
        }
        consume(); // }
        return { type: "IfStatement", test, consequent };
      }

      function parseFunctionDeclaration() {
        consume(); // function
        const name = consume();
        consume(); // (
        const params = [];
        while (peek() !== ")") {
          params.push(consume());
          if (peek() === ",") consume();
        }
        consume(); // )
        consume(); // {
        const body = [];
        while (peek() !== "}") {
          body.push(parseStatement());
        }
        consume(); // }
        return { type: "FunctionDeclaration", name, params, body };
      }

      function parseReturnStatement() {
        consume(); // return
        const value = parseExpression();
        consume(); // ;
        return { type: "ReturnStatement", value };
      }

      function parseExpressionStatement() {
        const expression = parseExpression();
        consume(); // ;
        return { type: "ExpressionStatement", expression };
      }

      function parseExpression() {
        return parseBinaryExpression();
      }

      function parseBinaryExpression() {
        let left = parsePrimary();

        while (["+", "-", "*", "/", "<", ">", "==", "!=", "<=", ">="].includes(peek())) {
          const operator = consume();
          const right = parsePrimary();
          left = { type: "BinaryExpression", operator, left, right };
        }

        return left;
      }

      function parsePrimary() {
        const token = consume();

        if (!isNaN(token)) {
          return { type: "Literal", value: Number(token) };
        }

        if (token.startsWith('"')) {
          return { type: "Literal", value: token.slice(1, -1) };
        }

        if (token === "(") {
          const expr = parseExpression();
          consume(); // )
          return expr;
        }

        if (peek() === "(") {
          consume(); // (
          const args = [];
          while (peek() !== ")") {
            args.push(parseExpression());
            if (peek() === ",") consume();
          }
          consume(); // )
          return { type: "CallExpression", callee: token, arguments: args };
        }

        return { type: "Identifier", name: token };
      }

      return parseProgram();
    }

    // ---------------- INTERPRETER ----------------
    function interpret(ast) {
      const env = {};
      const functions = {};

      function evalNode(node) {
        switch (node.type) {
          case "Program":
            for (const stmt of node.body) evalNode(stmt);
            break;

          case "VariableDeclaration":
            env[node.name] = evalNode(node.value);
            break;

          case "PrintStatement":
            const value = evalNode(node.argument);
            print(value);
            break;

          case "IfStatement":
            if (evalNode(node.test)) {
              for (const stmt of node.consequent) evalNode(stmt);
            }
            break;

          case "FunctionDeclaration":
            functions[node.name] = node;
            break;

          case "ReturnStatement":
            return { __return: true, value: evalNode(node.value) };

          case "ExpressionStatement":
            return evalNode(node.expression);

          case "BinaryExpression":
            return applyOperator(node.operator, evalNode(node.left), evalNode(node.right));

          case "Literal":
            return node.value;

          case "Identifier":
            if (env.hasOwnProperty(node.name)) return env[node.name];
            throw new Error("Undefined variable: " + node.name);

          case "CallExpression":
            return callFunction(node);
        }
      }

      function callFunction(node) {
        const func = functions[node.callee];
        if (!func) throw new Error("Undefined function: " + node.callee);

        const localEnv = { ...env };
        for (let i = 0; i < func.params.length; i++) {
          localEnv[func.params[i]] = evalNode(node.arguments[i]);
        }

        const oldEnv = Object.assign({}, env);
        Object.assign(env, localEnv);

        let result;
        for (const stmt of func.body) {
          const res = evalNode(stmt);
          if (res && res.__return) {
            result = res.value;
            break;
          }
        }

        Object.assign(env, oldEnv);
        return result;
      }

      function applyOperator(op, a, b) {
        switch (op) {
          case "+": return a + b;
          case "-": return a - b;
          case "*": return a * b;
          case "/": return a / b;
          case "<": return a < b;
          case ">": return a > b;
          case "==": return a === b;
          case "!=": return a !== b;
          case "<=": return a <= b;
          case ">=": return a >= b;
          default: throw new Error("Unknown operator: " + op);
        }
      }

      function print(value) {
        const outputDiv = document.getElementById("output");
        outputDiv.textContent += value + "\n";
      }

      evalNode(ast);
    }
  </script>
</body>
</html>
